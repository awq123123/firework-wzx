<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数字烟花 -王子轩</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        canvas {
            border: none;
            max-width: 100%;
            height: auto;
        }
    </style>
</head>
<body>
    <canvas id="fireworkCanvas" width="400" height="600"></canvas>

    <script>
        // 核心配置
        const CANVAS_WIDTH = 400;
        const CANVAS_HEIGHT = 600;
        const STAR_COUNT = 100;
        const FONT_SIZE = 20;
        const FONT_HEIGHT = 95;
        const FIREWORK_SPEED = 0.2;
        const PARTICLE_COUNT = 30; // 增加粒子数量，让轨迹更明显
        const IMAGE_POS_X = CANVAS_WIDTH / 2 - 50;
        const IMAGE_POS_Y = 0;

        // 获取画布上下文
        const canvas = document.getElementById('fireworkCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // 颜色列表
        const colorList = [
            [255,215,0], [255,140,0], [0,255,255], [127,255,212], [127,255,0],
            [0,250,154], [255,0,0], [255,69,0], [0,110,154], [255,128,128],
            [188,0,255], [255,0,239], [0,255,51]
        ];

        // ====================== 音频资源初始化（修改核心）=====================
        let riseAudio, explodeAudio;
        let audioLoaded = false; // 标记音频是否已加载
        let audioLoading = false; // 标记音频是否正在加载

        function preloadAudios() {
            return new Promise((resolve) => {
                if (audioLoaded) {
                    resolve();
                    return;
                }
                
                let loadedCount = 0;

                riseAudio = new Audio();
                riseAudio.src = './rise.mp3';
                riseAudio.preload = 'auto';
                riseAudio.volume = 0.2;
                riseAudio.oncanplaythrough = () => {
                    loadedCount++;
                    checkLoaded();
                };

                explodeAudio = new Audio();
                explodeAudio.src = './explode.mp3';
                explodeAudio.preload = 'auto';
                explodeAudio.volume = 1;
                explodeAudio.oncanplaythrough = () => {
                    loadedCount++;
                    checkLoaded();
                };

                function handleAudioError() {
                    loadedCount++;
                    checkLoaded();
                }
                riseAudio.onerror = handleAudioError;
                explodeAudio.onerror = handleAudioError;

                function checkLoaded() {
                    if (loadedCount >= 2) {
                        audioLoaded = true;
                        resolve();
                    }
                }
            });
        }

        function playAudio(audio) {
            if (!audio || !audioLoaded) return;
            audio.currentTime = 0;
            audio.play().catch(err => {
                console.log('音频播放失败:', err);
            });
        }

        // ====================== 图片资源初始化 ======================
        const images = [];
        const imagePaths = [
            './image1.png',
            './image2.png',
            './image3.png'
        ];

        function preloadImages() {
            return new Promise((resolve) => {
                let loadedCount = 0;
                
                imagePaths.forEach((path, index) => {
                    const img = new Image();
                    img.src = path;
                    img.onload = () => {
                        images[index] = img;
                        loadedCount++;
                        if (loadedCount === imagePaths.length) {
                            resolve();
                        }
                    };
                    img.onerror = () => {
                        console.error(`图片加载失败: ${path}`);
                        loadedCount++;
                        if (loadedCount === imagePaths.length) {
                            resolve();
                        }
                    };
                });
            });
        }

        // ====================== 星星系统 ======================
        let stars = [];
        function initStars() {
            stars = [];
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * CANVAS_HEIGHT,
                    size: Math.random() * 2 + 2,
                    brightness: Math.random() * 0.8 + 0.2,
                    speed: Math.random() * 0.01 + 0.01,
                    direction: Math.random() > 0.5 ? 1 : -1
                });
            }
        }

        function updateStars() {
            for (let star of stars) {
                star.brightness += star.speed * star.direction;
                if (star.brightness <= 0.2) {
                    star.brightness = 0.2;
                    star.direction = 1;
                } else if (star.brightness >= 1.0) {
                    star.brightness = 1.0;
                    star.direction = -1;
                }
                const c = Math.floor(255 * star.brightness);
                ctx.fillStyle = `rgb(${c}, ${c}, ${c})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ====================== 10种轨迹粒子系统（核心重构）=====================
        // 轨迹类型枚举
        const TRAJECTORY_TYPES = {
            0: 'SINE_WAVE',        // 正弦波轨迹
            1: 'CIRCULAR_WAVE',    // 圆形波纹轨迹
            2: 'SPIRAL',           // 螺旋轨迹
            3: 'HEART',            // 爱心轨迹
            4: 'COMET',            // 彗星拖尾轨迹
            5: 'LIGHTNING',        // 闪电折线轨迹
            6: 'PETAL',            // 花瓣轨迹
            7: 'RAINBOW',          // 彩虹弧形轨迹
            8: 'METEOR',           // 流星轨迹
            9: 'QUANTUM_RANDOM'    // 量子随机轨迹
        };

        class Particle {
            constructor(x, y, color, trajectoryType) {
                // 基础属性
                this.x = x;
                this.y = y;
                this.color = color;
                this.life = Math.floor(Math.random() * 40) + 20; // 延长生命周期，显示完整轨迹
                this.maxLife = this.life;
                this.size = Math.random() * 3 + 2; // 粒子大小
                
                // 轨迹相关属性
                this.trajectoryType = trajectoryType;
                this.angle = Math.random() * Math.PI * 2; // 初始角度（用于圆形/螺旋等）
                this.speed = Math.random() * 4 + 2; // 基础速度
                this.progress = 0; // 轨迹进度（0-1）
                this.offsetX = 0; // 偏移量（用于正弦波等）
                this.offsetY = 0; // 偏移量
                this.phase = Math.random() * Math.PI * 2; // 相位（用于正弦波）
                this.lightningSteps = []; // 闪电轨迹的折点
                this.heartScale = 0; // 爱心轨迹缩放
                
                // 初始化特定轨迹
                this.initTrajectory();
            }

            // 初始化不同轨迹的专属参数
            initTrajectory() {
                switch (this.trajectoryType) {
                    case 'LIGHTNING':
                        // 生成闪电折点
                        this.lightningSteps = [];
                        let currentX = this.x;
                        let currentY = this.y;
                        for (let i = 0; i < 8; i++) {
                            currentX += (Math.random() - 0.5) * 20;
                            currentY += (Math.random() - 0.5) * 20;
                            this.lightningSteps.push({x: currentX, y: currentY});
                        }
                        break;
                    case 'HEART':
                        this.heartScale = 0;
                        break;
                    case 'QUANTUM_RANDOM':
                        this.quantumStep = 0;
                        break;
                }
            }

            // 10种轨迹的运动逻辑
            updateTrajectory() {
                this.progress = 1 - (this.life / this.maxLife);
                const speedFactor = this.speed * (1 - this.progress); // 减速效果
                
                switch (this.trajectoryType) {
                    // 1. 正弦波轨迹：左右摆动前进
                    case 'SINE_WAVE':
                        this.angle += 0.1;
                        this.offsetX = Math.sin(this.angle * 3 + this.phase) * 20;
                        this.x += Math.cos(this.angle) * speedFactor + this.offsetX * 0.1;
                        this.y += Math.sin(this.angle) * speedFactor + Math.sin(this.progress * Math.PI) * 5;
                        break;
                    
                    // 2. 圆形波纹轨迹：向外扩散的同心圆
                    case 'CIRCULAR_WAVE':
                        const radius = this.progress * 80; // 波纹半径
                        this.x = this.x + Math.cos(this.angle) * radius;
                        this.y = this.y + Math.sin(this.angle) * radius;
                        // 波纹脉动效果
                        this.size = Math.sin(this.progress * Math.PI * 8) * 2 + 2;
                        break;
                    
                    // 3. 螺旋轨迹：螺旋向外扩散
                    case 'SPIRAL':
                        const spiralRadius = this.progress * 60;
                        this.angle += 0.2;
                        this.x = this.x + Math.cos(this.angle) * spiralRadius;
                        this.y = this.y + Math.sin(this.angle) * spiralRadius;
                        break;
                    
                    // 4. 爱心轨迹：形成爱心形状
                    case 'HEART':
                        this.heartScale += 0.1;
                        const t = this.angle;
                        const heartX = 16 * Math.pow(Math.sin(t), 3);
                        const heartY = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                        this.x += heartX * this.heartScale * 0.5;
                        this.y += heartY * this.heartScale * 0.5;
                        break;
                    
                    // 5. 彗星轨迹：带拖尾的直线
                    case 'COMET':
                        this.x += Math.cos(this.angle) * speedFactor * 1.5;
                        this.y += Math.sin(this.angle) * speedFactor * 1.5;
                        // 拖尾效果：粒子大小随生命周期变化
                        this.size = Math.sin(this.progress * Math.PI) * 4 + 1;
                        break;
                    
                    // 6. 闪电轨迹：折线前进
                    case 'LIGHTNING':
                        if (this.lightningSteps.length > 0) {
                            const stepIndex = Math.floor(this.progress * this.lightningSteps.length);
                            const target = this.lightningSteps[Math.min(stepIndex, this.lightningSteps.length - 1)];
                            this.x = target.x;
                            this.y = target.y;
                        }
                        break;
                    
                    // 7. 花瓣轨迹：6瓣花形状
                    case 'PETAL':
                        const petalAngle = this.angle * 6; // 6瓣
                        const petalRadius = Math.cos(petalAngle) * 20 + 30;
                        this.x = this.x + Math.cos(this.angle) * petalRadius * this.progress;
                        this.y = this.y + Math.sin(this.angle) * petalRadius * this.progress;
                        break;
                    
                    // 8. 彩虹轨迹：弧形
                    case 'RAINBOW':
                        const rainbowRadius = 80;
                        const rainbowAngle = this.progress * Math.PI + this.phase;
                        this.x = this.x + Math.cos(rainbowAngle) * rainbowRadius;
                        this.y = this.y + Math.sin(rainbowAngle) * rainbowRadius * 0.5;
                        break;
                    
                    // 9. 流星轨迹：斜向前进+尾部扩散
                    case 'METEOR':
                        this.x += Math.cos(this.angle) * speedFactor * 2;
                        this.y += Math.sin(this.angle) * speedFactor * 2 + this.progress * 5;
                        // 尾部变亮
                        const alpha = 1 - this.progress;
                        ctx.globalAlpha = alpha;
                        break;
                    
                    // 10. 量子随机轨迹：随机瞬移
                    case 'QUANTUM_RANDOM':
                        this.quantumStep++;
                        if (this.quantumStep % 3 === 0) { // 每3帧瞬移一次
                            this.x += (Math.random() - 0.5) * 30;
                            this.y += (Math.random() - 0.5) * 30;
                        }
                        break;
                }

                // 通用效果：粒子透明度随生命周期降低
                this.alpha = this.life / this.maxLife;
                ctx.globalAlpha = this.alpha > 0 ? this.alpha : 0;
            }

            // 更新粒子
            update() {
                this.life--;
                if (this.life <= 0) return false;

                // 更新轨迹
                this.updateTrajectory();

                // 绘制粒子
                ctx.fillStyle = `rgb(${this.color[0]}, ${this.color[1]}, ${this.color[2]})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();

                // 重置透明度
                ctx.globalAlpha = 1;
                
                return true;
            }
        }

        // ====================== 烟花系统 ======================
        class Firework {
            constructor(targetX, targetY) {
                this.x = targetX;
                this.targetY = targetY;
                this.speed = FIREWORK_SPEED;
                this.color = colorList[Math.floor(Math.random() * colorList.length)];
                this.drops = [CANVAS_HEIGHT / FONT_HEIGHT];
                this.exploded = false;
                this.riseAudioPlayed = false;
                // 随机选择本次烟花的轨迹类型（整簇烟花统一类型，效果更美观）
                this.trajectoryType = TRAJECTORY_TYPES[Math.floor(Math.random() * 10)];
            }

            update() {
                if (this.exploded) return;

                if (!this.riseAudioPlayed) {
                    playAudio(riseAudio);
                    this.riseAudioPlayed = true;
                }

                for (let i = 0; i < this.drops.length; i++) {
                    const text = Math.floor(Math.random() * 10).toString();
                    ctx.font = `${FONT_SIZE}px "Microsoft YaHei", "SimHei", Arial`;
                    ctx.fillStyle = `rgb(${this.color[0]}, ${this.color[1]}, ${this.color[2]})`;
                    const xPos = this.x - 15;
                    const yPos = this.drops[i] * FONT_HEIGHT;
                    ctx.fillText(text, xPos, yPos);
                    this.drops[i] -= this.speed;

                    if (this.drops[i] * FONT_HEIGHT <= this.targetY && !this.exploded) {
                        this.exploded = true;
                        this.createParticles(xPos + 10, yPos);
                    }
                }
            }

            createParticles(x, y) {
                playAudio(explodeAudio);

                // 1/10概率显示图片
                const rand = Math.floor(Math.random() * 10) + 1;
                if (rand === 1) {
                    const imgIndex = Math.floor(Math.random() * 3);
                    if (images[imgIndex]) {
                        ctx.drawImage(images[imgIndex], IMAGE_POS_X, IMAGE_POS_Y);
                    }
                }

                // 生成粒子（使用随机选中的轨迹类型）
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    particles.push(new Particle(x, y, this.color, this.trajectoryType));
                }
            }
        }

        // ====================== 全局变量 & 多点触控交互（修改核心）=====================
        let fireworks = [];
        let particles = [];

        // 初始化音频（首次点击时执行）
        async function initAudioOnFirstClick() {
            if (audioLoading) return;
            audioLoading = true;
            await preloadAudios();
            audioLoading = false;
        }

        function createFireworkAtPosition(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const clickX = (clientX - rect.left) * (CANVAS_WIDTH / rect.width);
            const clickY = (clientY - rect.top) * (CANVAS_HEIGHT / rect.height);
            
            // 首次点击先加载音频，再创建烟花
            if (!audioLoaded && !audioLoading) {
                initAudioOnFirstClick().then(() => {
                    fireworks.push(new Firework(clickX, clickY));
                });
            } else {
                fireworks.push(new Firework(clickX, clickY));
            }
        }

        canvas.addEventListener('click', (e) => {
            createFireworkAtPosition(e.clientX, e.clientY);
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.touches.length; i++) {
                const touch = e.touches[i];
                createFireworkAtPosition(touch.clientX, touch.clientY);
            }
        }, { passive: false });

        // ====================== 主循环 ======================
        function mainLoop() {
            requestAnimationFrame(mainLoop);

            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            updateStars();

            // 更新烟花
            const activeFireworks = [];
            for (let fw of fireworks) {
                fw.update();
                if (!fw.exploded) {
                    activeFireworks.push(fw);
                }
            }
            fireworks = activeFireworks;

            // 更新粒子
            const activeParticles = [];
            for (let p of particles) {
                if (p.update()) {
                    activeParticles.push(p);
                }
            }
            particles = activeParticles;
        }

        // ====================== 初始化（修改核心）=====================
        initStars();
        // 只预加载图片，音频改为点击时加载
        preloadImages().then(() => {
            mainLoop();
            window.dispatchEvent(new Event('resize'));
        });

        // 窗口适配
        window.addEventListener('resize', () => {
            const scale = Math.min(
                window.innerWidth / CANVAS_WIDTH,
                window.innerHeight / CANVAS_HEIGHT
            );
            canvas.style.transform = `scale(${scale})`;
        });
    </script>
</body>
</html>

